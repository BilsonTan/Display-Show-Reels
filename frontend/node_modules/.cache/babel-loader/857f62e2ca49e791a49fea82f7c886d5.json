{"ast":null,"code":"/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['moment'], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but only CommonJS-like\n    // enviroments that support module.exports, like Node.\n    try {\n      module.exports = factory(require('moment'));\n    } catch (e) {\n      // If moment is not available, leave the setup up to the user.\n      // Like when using moment-timezone or similar moment-based package.\n      module.exports = factory;\n    }\n  }\n\n  if (root) {\n    // Globals.\n    root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n  }\n})(this, function (moment) {\n  // `Number#tolocaleString` is tested on plugin initialization.\n  // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n  // native function will be used to generate formatted output. If the feature\n  // test fails, the fallback format function internal to this plugin will be\n  // used.\n  var toLocaleStringWorks = false; // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `toLocaleString` will be used for formatting,\n  // the plugin will \"pre-round\" number values using the fallback number format\n  // function before passing them to `toLocaleString` for final formatting.\n\n  var toLocaleStringRoundingWorks = false; // `Intl.NumberFormat#format` is tested on plugin initialization.\n  // If the feature test passes, `intlNumberFormatRoundingWorks` will be set to\n  // `true` and the native function will be used to generate formatted output.\n  // If the feature test fails, either `Number#tolocaleString` (if\n  // `toLocaleStringWorks` is `true`), or the fallback format function internal\n  //  to this plugin will be used.\n\n  var intlNumberFormatWorks = false; // `Intl.NumberFormat#format` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `Intl.NumberFormat#format` will be used for\n  // formatting, the plugin will \"pre-round\" number values using the fallback number\n  // format function before passing them to `Intl.NumberFormat#format` for final\n  // formatting.\n\n  var intlNumberFormatRoundingWorks = false; // Token type names in order of descending magnitude.\n\n  var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n  var bubbles = [{\n    type: \"seconds\",\n    targets: [{\n      type: \"minutes\",\n      value: 60\n    }, {\n      type: \"hours\",\n      value: 3600\n    }, {\n      type: \"days\",\n      value: 86400\n    }, {\n      type: \"weeks\",\n      value: 604800\n    }, {\n      type: \"months\",\n      value: 2678400\n    }, {\n      type: \"years\",\n      value: 31536000\n    }]\n  }, {\n    type: \"minutes\",\n    targets: [{\n      type: \"hours\",\n      value: 60\n    }, {\n      type: \"days\",\n      value: 1440\n    }, {\n      type: \"weeks\",\n      value: 10080\n    }, {\n      type: \"months\",\n      value: 44640\n    }, {\n      type: \"years\",\n      value: 525600\n    }]\n  }, {\n    type: \"hours\",\n    targets: [{\n      type: \"days\",\n      value: 24\n    }, {\n      type: \"weeks\",\n      value: 168\n    }, {\n      type: \"months\",\n      value: 744\n    }, {\n      type: \"years\",\n      value: 8760\n    }]\n  }, {\n    type: \"days\",\n    targets: [{\n      type: \"weeks\",\n      value: 7\n    }, {\n      type: \"months\",\n      value: 31\n    }, {\n      type: \"years\",\n      value: 365\n    }]\n  }, {\n    type: \"months\",\n    targets: [{\n      type: \"years\",\n      value: 12\n    }]\n  }]; // stringIncludes\n\n  function stringIncludes(str, search) {\n    if (search.length > str.length) {\n      return false;\n    }\n\n    return str.indexOf(search) !== -1;\n  } // repeatZero(qty)\n  // Returns \"0\" repeated `qty` times.\n  // `qty` must be a integer >= 0.\n\n\n  function repeatZero(qty) {\n    var result = \"\";\n\n    while (qty) {\n      result += \"0\";\n      qty -= 1;\n    }\n\n    return result;\n  }\n\n  function stringRound(digits) {\n    var digitsArray = digits.split(\"\").reverse();\n    var i = 0;\n    var carry = true;\n\n    while (carry && i < digitsArray.length) {\n      if (i) {\n        if (digitsArray[i] === \"9\") {\n          digitsArray[i] = \"0\";\n        } else {\n          digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n          carry = false;\n        }\n      } else {\n        if (parseInt(digitsArray[i], 10) < 5) {\n          carry = false;\n        }\n\n        digitsArray[i] = \"0\";\n      }\n\n      i += 1;\n    }\n\n    if (carry) {\n      digitsArray.push(\"1\");\n    }\n\n    return digitsArray.reverse().join(\"\");\n  } // cachedNumberFormat\n  // Returns an `Intl.NumberFormat` instance for the given locale and configuration.\n  // On first use of a particular configuration, the instance is cached for fast\n  // repeat access.\n\n\n  function cachedNumberFormat(locale, options) {\n    // Create a sorted, stringified version of `options`\n    // for use as part of the cache key\n    var optionsString = map(keys(options).sort(), function (key) {\n      return key + ':' + options[key];\n    }).join(','); // Set our cache key\n\n    var cacheKey = locale + '+' + optionsString; // If we don't have this configuration cached, configure and cache it\n\n    if (!cachedNumberFormat.cache[cacheKey]) {\n      cachedNumberFormat.cache[cacheKey] = Intl.NumberFormat(locale, options);\n    } // Return the cached version of this configuration\n\n\n    return cachedNumberFormat.cache[cacheKey];\n  }\n\n  cachedNumberFormat.cache = {}; // formatNumber\n  // Formats any number greater than or equal to zero using these options:\n  // - userLocale\n  // - useToLocaleString\n  // - useGrouping\n  // - grouping\n  // - maximumSignificantDigits\n  // - minimumIntegerDigits\n  // - fractionDigits\n  // - groupingSeparator\n  // - decimalSeparator\n  //\n  // `useToLocaleString` will use `Intl.NumberFormat` or `toLocaleString` for formatting.\n  // `userLocale` option is passed through to the formatting function.\n  // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n  // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n\n  function formatNumber(number, options, userLocale) {\n    var useToLocaleString = options.useToLocaleString;\n    var useGrouping = options.useGrouping;\n    var grouping = useGrouping && options.grouping.slice();\n    var maximumSignificantDigits = options.maximumSignificantDigits;\n    var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n    var fractionDigits = options.fractionDigits || 0;\n    var groupingSeparator = options.groupingSeparator;\n    var decimalSeparator = options.decimalSeparator;\n\n    if (useToLocaleString && userLocale) {\n      var localeStringOptions = {\n        minimumIntegerDigits: minimumIntegerDigits,\n        useGrouping: useGrouping\n      };\n\n      if (fractionDigits) {\n        localeStringOptions.maximumFractionDigits = fractionDigits;\n        localeStringOptions.minimumFractionDigits = fractionDigits;\n      } // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n      // when maximumSignificantDigits is set. See #96.\n\n\n      if (maximumSignificantDigits && number > 0) {\n        localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n      }\n\n      if (intlNumberFormatWorks) {\n        if (!intlNumberFormatRoundingWorks) {\n          var roundingOptions = extend({}, options);\n          roundingOptions.useGrouping = false;\n          roundingOptions.decimalSeparator = \".\";\n          number = parseFloat(formatNumber(number, roundingOptions), 10);\n        }\n\n        return cachedNumberFormat(userLocale, localeStringOptions).format(number);\n      } else {\n        if (!toLocaleStringRoundingWorks) {\n          var roundingOptions = extend({}, options);\n          roundingOptions.useGrouping = false;\n          roundingOptions.decimalSeparator = \".\";\n          number = parseFloat(formatNumber(number, roundingOptions), 10);\n        }\n\n        return number.toLocaleString(userLocale, localeStringOptions);\n      }\n    }\n\n    var numberString; // Add 1 to digit output length for floating point errors workaround. See below.\n\n    if (maximumSignificantDigits) {\n      numberString = number.toPrecision(maximumSignificantDigits + 1);\n    } else {\n      numberString = number.toFixed(fractionDigits + 1);\n    }\n\n    var integerString;\n    var fractionString;\n    var exponentString;\n    var temp = numberString.split(\"e\");\n    exponentString = temp[1] || \"\";\n    temp = temp[0].split(\".\");\n    fractionString = temp[1] || \"\";\n    integerString = temp[0] || \"\"; // Workaround for floating point errors in `toFixed` and `toPrecision`.\n    // (3.55).toFixed(1); --> \"3.5\"\n    // (123.55 - 120).toPrecision(2); --> \"3.5\"\n    // (123.55 - 120); --> 3.549999999999997\n    // (123.55 - 120).toFixed(2); --> \"3.55\"\n    // Round by examing the string output of the next digit.\n    // *************** Implement String Rounding here ***********************\n    // Check integerString + fractionString length of toPrecision before rounding.\n    // Check length of fractionString from toFixed output before rounding.\n\n    var integerLength = integerString.length;\n    var fractionLength = fractionString.length;\n    var digitCount = integerLength + fractionLength;\n    var digits = integerString + fractionString;\n\n    if (maximumSignificantDigits && digitCount === maximumSignificantDigits + 1 || !maximumSignificantDigits && fractionLength === fractionDigits + 1) {\n      // Round digits.\n      digits = stringRound(digits);\n\n      if (digits.length === digitCount + 1) {\n        integerLength = integerLength + 1;\n      } // Discard final fractionDigit.\n\n\n      if (fractionLength) {\n        digits = digits.slice(0, -1);\n      } // Separate integer and fraction.\n\n\n      integerString = digits.slice(0, integerLength);\n      fractionString = digits.slice(integerLength);\n    } // Trim trailing zeroes from fractionString because toPrecision outputs\n    // precision, not significant digits.\n\n\n    if (maximumSignificantDigits) {\n      fractionString = fractionString.replace(/0*$/, \"\");\n    } // Handle exponent.\n\n\n    var exponent = parseInt(exponentString, 10);\n\n    if (exponent > 0) {\n      if (fractionString.length <= exponent) {\n        fractionString = fractionString + repeatZero(exponent - fractionString.length);\n        integerString = integerString + fractionString;\n        fractionString = \"\";\n      } else {\n        integerString = integerString + fractionString.slice(0, exponent);\n        fractionString = fractionString.slice(exponent);\n      }\n    } else if (exponent < 0) {\n      fractionString = repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString;\n      integerString = \"0\";\n    }\n\n    if (!maximumSignificantDigits) {\n      // Trim or pad fraction when not using maximumSignificantDigits.\n      fractionString = fractionString.slice(0, fractionDigits);\n\n      if (fractionString.length < fractionDigits) {\n        fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n      } // Pad integer when using minimumIntegerDigits\n      // and not using maximumSignificantDigits.\n\n\n      if (integerString.length < minimumIntegerDigits) {\n        integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n      }\n    }\n\n    var formattedString = \"\"; // Handle grouping.\n\n    if (useGrouping) {\n      temp = integerString;\n      var group;\n\n      while (temp.length) {\n        if (grouping.length) {\n          group = grouping.shift();\n        }\n\n        if (formattedString) {\n          formattedString = groupingSeparator + formattedString;\n        }\n\n        formattedString = temp.slice(-group) + formattedString;\n        temp = temp.slice(0, -group);\n      }\n    } else {\n      formattedString = integerString;\n    } // Add decimalSeparator and fraction.\n\n\n    if (fractionString) {\n      formattedString = formattedString + decimalSeparator + fractionString;\n    }\n\n    return formattedString;\n  } // durationLabelCompare\n\n\n  function durationLabelCompare(a, b) {\n    if (a.label.length > b.label.length) {\n      return -1;\n    }\n\n    if (a.label.length < b.label.length) {\n      return 1;\n    } // a must be equal to b\n\n\n    return 0;\n  } // durationGetLabels\n\n\n  function durationGetLabels(token, localeData) {\n    var labels = [];\n    each(keys(localeData), function (localeDataKey) {\n      if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n        return;\n      }\n\n      var labelType = localeDataKey.slice(15).toLowerCase();\n      each(keys(localeData[localeDataKey]), function (labelKey) {\n        if (labelKey.slice(0, 1) === token) {\n          labels.push({\n            type: labelType,\n            key: labelKey,\n            label: localeData[localeDataKey][labelKey]\n          });\n        }\n      });\n    });\n    return labels;\n  } // durationPluralKey\n\n\n  function durationPluralKey(token, integerValue, decimalValue) {\n    // Singular for a value of `1`, but not for `1.0`.\n    if (integerValue === 1 && decimalValue === null) {\n      return token;\n    }\n\n    return token + token;\n  }\n\n  var engLocale = {\n    durationLabelsStandard: {\n      S: 'millisecond',\n      SS: 'milliseconds',\n      s: 'second',\n      ss: 'seconds',\n      m: 'minute',\n      mm: 'minutes',\n      h: 'hour',\n      hh: 'hours',\n      d: 'day',\n      dd: 'days',\n      w: 'week',\n      ww: 'weeks',\n      M: 'month',\n      MM: 'months',\n      y: 'year',\n      yy: 'years'\n    },\n    durationLabelsShort: {\n      S: 'msec',\n      SS: 'msecs',\n      s: 'sec',\n      ss: 'secs',\n      m: 'min',\n      mm: 'mins',\n      h: 'hr',\n      hh: 'hrs',\n      d: 'dy',\n      dd: 'dys',\n      w: 'wk',\n      ww: 'wks',\n      M: 'mo',\n      MM: 'mos',\n      y: 'yr',\n      yy: 'yrs'\n    },\n    durationTimeTemplates: {\n      HMS: 'h:mm:ss',\n      HM: 'h:mm',\n      MS: 'm:ss'\n    },\n    durationLabelTypes: [{\n      type: \"standard\",\n      string: \"__\"\n    }, {\n      type: \"short\",\n      string: \"_\"\n    }],\n    durationPluralKey: durationPluralKey\n  }; // isArray\n\n  function isArray(array) {\n    return Object.prototype.toString.call(array) === \"[object Array]\";\n  } // isObject\n\n\n  function isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  } // findLast\n\n\n  function findLast(array, callback) {\n    var index = array.length;\n\n    while (index -= 1) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n    }\n  } // find\n\n\n  function find(array, callback) {\n    var index = 0;\n    var max = array && array.length || 0;\n    var match;\n\n    if (typeof callback !== \"function\") {\n      match = callback;\n\n      callback = function (item) {\n        return item === match;\n      };\n    }\n\n    while (index < max) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n\n      index += 1;\n    }\n  } // each\n\n\n  function each(array, callback) {\n    var index = 0,\n        max = array.length;\n\n    if (!array || !max) {\n      return;\n    }\n\n    while (index < max) {\n      if (callback(array[index], index) === false) {\n        return;\n      }\n\n      index += 1;\n    }\n  } // map\n\n\n  function map(array, callback) {\n    var index = 0,\n        max = array.length,\n        ret = [];\n\n    if (!array || !max) {\n      return ret;\n    }\n\n    while (index < max) {\n      ret[index] = callback(array[index], index);\n      index += 1;\n    }\n\n    return ret;\n  } // pluck\n\n\n  function pluck(array, prop) {\n    return map(array, function (item) {\n      return item[prop];\n    });\n  } // compact\n\n\n  function compact(array) {\n    var ret = [];\n    each(array, function (item) {\n      if (item) {\n        ret.push(item);\n      }\n    });\n    return ret;\n  } // unique\n\n\n  function unique(array) {\n    var ret = [];\n    each(array, function (_a) {\n      if (!find(ret, _a)) {\n        ret.push(_a);\n      }\n    });\n    return ret;\n  } // intersection\n\n\n  function intersection(a, b) {\n    var ret = [];\n    each(a, function (_a) {\n      each(b, function (_b) {\n        if (_a === _b) {\n          ret.push(_a);\n        }\n      });\n    });\n    return unique(ret);\n  } // rest\n\n\n  function rest(array, callback) {\n    var ret = [];\n    each(array, function (item, index) {\n      if (!callback(item)) {\n        ret = array.slice(index);\n        return false;\n      }\n    });\n    return ret;\n  } // initial\n\n\n  function initial(array, callback) {\n    var reversed = array.slice().reverse();\n    return rest(reversed, callback).reverse();\n  } // extend\n\n\n  function extend(a, b) {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n\n    return a;\n  } // keys\n\n\n  function keys(a) {\n    var ret = [];\n\n    for (var key in a) {\n      if (a.hasOwnProperty(key)) {\n        ret.push(key);\n      }\n    }\n\n    return ret;\n  } // any\n\n\n  function any(array, callback) {\n    var index = 0,\n        max = array.length;\n\n    if (!array || !max) {\n      return false;\n    }\n\n    while (index < max) {\n      if (callback(array[index], index) === true) {\n        return true;\n      }\n\n      index += 1;\n    }\n\n    return false;\n  } // flatten\n\n\n  function flatten(array) {\n    var ret = [];\n    each(array, function (child) {\n      ret = ret.concat(child);\n    });\n    return ret;\n  }\n\n  function toLocaleStringSupportsLocales() {\n    var number = 0;\n\n    try {\n      number.toLocaleString('i');\n    } catch (e) {\n      return e.name === 'RangeError';\n    }\n\n    return false;\n  }\n\n  function featureTestFormatterRounding(formatter) {\n    return formatter(3.55, \"en\", {\n      useGrouping: false,\n      minimumIntegerDigits: 1,\n      minimumFractionDigits: 1,\n      maximumFractionDigits: 1\n    }) === \"3.6\";\n  }\n\n  function featureTestFormatter(formatter) {\n    var passed = true; // Test minimumIntegerDigits.\n\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 1\n    }) === \"1\";\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 2\n    }) === \"01\";\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 3\n    }) === \"001\";\n\n    if (!passed) {\n      return false;\n    } // Test maximumFractionDigits and minimumFractionDigits.\n\n\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 0,\n      minimumFractionDigits: 0\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 1,\n      minimumFractionDigits: 1\n    }) === \"100.0\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 2,\n      minimumFractionDigits: 2\n    }) === \"99.99\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 3,\n      minimumFractionDigits: 3\n    }) === \"99.990\";\n\n    if (!passed) {\n      return false;\n    } // Test maximumSignificantDigits.\n\n\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 1\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 2\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 3\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 4\n    }) === \"99.99\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 5\n    }) === \"99.99\";\n\n    if (!passed) {\n      return false;\n    } // Test grouping.\n\n\n    passed = passed && formatter(1000, \"en\", {\n      useGrouping: true\n    }) === \"1,000\";\n    passed = passed && formatter(1000, \"en\", {\n      useGrouping: false\n    }) === \"1000\";\n\n    if (!passed) {\n      return false;\n    }\n\n    return true;\n  } // durationsFormat(durations [, template] [, precision] [, settings])\n\n\n  function durationsFormat() {\n    var args = [].slice.call(arguments);\n    var settings = {};\n    var durations; // Parse arguments.\n\n    each(args, function (arg, index) {\n      if (!index) {\n        if (!isArray(arg)) {\n          throw \"Expected array as the first argument to durationsFormat.\";\n        }\n\n        durations = arg;\n      }\n\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n\n    if (!durations || !durations.length) {\n      return [];\n    }\n\n    settings.returnMomentTypes = true;\n    var formattedDurations = map(durations, function (dur) {\n      return dur.format(settings);\n    }); // Merge token types from all durations.\n\n    var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n    var largest = settings.largest;\n\n    if (largest) {\n      outputTypes = outputTypes.slice(0, largest);\n    }\n\n    settings.returnMomentTypes = false;\n    settings.outputTypes = outputTypes;\n    return map(durations, function (dur) {\n      return dur.format(settings);\n    });\n  } // durationFormat([template] [, precision] [, settings])\n\n\n  function durationFormat() {\n    var args = [].slice.call(arguments);\n    var settings = extend({}, this.format.defaults); // Keep a shadow copy of this moment for calculating remainders.\n    // Perform all calculations on positive duration value, handle negative\n    // sign at the very end.\n\n    var asMilliseconds = this.asMilliseconds();\n    var asMonths = this.asMonths(); // Treat invalid durations as having a value of 0 milliseconds.\n\n    if (typeof this.isValid === \"function\" && this.isValid() === false) {\n      asMilliseconds = 0;\n      asMonths = 0;\n    }\n\n    var isNegative = asMilliseconds < 0; // Two shadow copies are needed because of the way moment.js handles\n    // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n\n    var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n    var remainderMonths = moment.duration(Math.abs(asMonths), \"months\"); // Parse arguments.\n\n    each(args, function (arg) {\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n    var momentTokens = {\n      years: \"y\",\n      months: \"M\",\n      weeks: \"w\",\n      days: \"d\",\n      hours: \"h\",\n      minutes: \"m\",\n      seconds: \"s\",\n      milliseconds: \"S\"\n    };\n    var tokenDefs = {\n      escape: /\\[(.+?)\\]/,\n      years: /\\*?[Yy]+/,\n      months: /\\*?M+/,\n      weeks: /\\*?[Ww]+/,\n      days: /\\*?[Dd]+/,\n      hours: /\\*?[Hh]+/,\n      minutes: /\\*?m+/,\n      seconds: /\\*?s+/,\n      milliseconds: /\\*?S+/,\n      general: /.+?/\n    }; // Types array is available in the template function.\n\n    settings.types = types;\n\n    var typeMap = function (token) {\n      return find(types, function (type) {\n        return tokenDefs[type].test(token);\n      });\n    };\n\n    var tokenizer = new RegExp(map(types, function (type) {\n      return tokenDefs[type].source;\n    }).join(\"|\"), \"g\"); // Current duration object is available in the template function.\n\n    settings.duration = this; // Eval template function and cache template string.\n\n    var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template; // outputTypes and returnMomentTypes are settings to support durationsFormat().\n    // outputTypes is an array of moment token types that determines\n    // the tokens returned in formatted output. This option overrides\n    // trim, largest, stopTrim, etc.\n\n    var outputTypes = settings.outputTypes; // returnMomentTypes is a boolean that sets durationFormat to return\n    // the processed momentTypes instead of formatted output.\n\n    var returnMomentTypes = settings.returnMomentTypes;\n    var largest = settings.largest; // Setup stopTrim array of token types.\n\n    var stopTrim = [];\n\n    if (!outputTypes) {\n      if (isArray(settings.stopTrim)) {\n        settings.stopTrim = settings.stopTrim.join(\"\");\n      } // Parse stopTrim string to create token types array.\n\n\n      if (settings.stopTrim) {\n        each(settings.stopTrim.match(tokenizer), function (token) {\n          var type = typeMap(token);\n\n          if (type === \"escape\" || type === \"general\") {\n            return;\n          }\n\n          stopTrim.push(type);\n        });\n      }\n    } // Cache moment's locale data.\n\n\n    var localeData = moment.localeData();\n\n    if (!localeData) {\n      localeData = {};\n    } // Fall back to this plugin's `eng` extension.\n\n\n    each(keys(engLocale), function (key) {\n      if (typeof engLocale[key] === \"function\") {\n        if (!localeData[key]) {\n          localeData[key] = engLocale[key];\n        }\n\n        return;\n      }\n\n      if (!localeData[\"_\" + key]) {\n        localeData[\"_\" + key] = engLocale[key];\n      }\n    }); // Replace Duration Time Template strings.\n    // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n\n    each(keys(localeData._durationTimeTemplates), function (item) {\n      template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n    }); // Determine user's locale.\n\n    var userLocale = settings.userLocale || moment.locale();\n    var useLeftUnits = settings.useLeftUnits;\n    var usePlural = settings.usePlural;\n    var precision = settings.precision;\n    var forceLength = settings.forceLength;\n    var useGrouping = settings.useGrouping;\n    var trunc = settings.trunc; // Use significant digits only when precision is greater than 0.\n\n    var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n    var significantDigits = useSignificantDigits ? settings.precision : 0;\n    var significantDigitsCache = significantDigits;\n    var minValue = settings.minValue;\n    var isMinValue = false;\n    var maxValue = settings.maxValue;\n    var isMaxValue = false; // formatNumber fallback options.\n\n    var useToLocaleString = settings.useToLocaleString;\n    var groupingSeparator = settings.groupingSeparator;\n    var decimalSeparator = settings.decimalSeparator;\n    var grouping = settings.grouping;\n    useToLocaleString = useToLocaleString && (toLocaleStringWorks || intlNumberFormatWorks); // Trim options.\n\n    var trim = settings.trim;\n\n    if (isArray(trim)) {\n      trim = trim.join(\" \");\n    }\n\n    if (trim === null && (largest || maxValue || useSignificantDigits)) {\n      trim = \"all\";\n    }\n\n    if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n      trim = \"large\";\n    }\n\n    if (trim === false) {\n      trim = \"\";\n    }\n\n    var trimIncludes = function (item) {\n      return item.test(trim);\n    };\n\n    var rLarge = /large/;\n    var rSmall = /small/;\n    var rBoth = /both/;\n    var rMid = /mid/;\n    var rAll = /^all|[^sm]all/;\n    var rFinal = /final/;\n    var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n    var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n    var trimMid = any([rMid, rAll], trimIncludes);\n    var trimFinal = any([rFinal, rAll], trimIncludes); // Parse format string to create raw tokens array.\n\n    var rawTokens = map(template.match(tokenizer), function (token, index) {\n      var type = typeMap(token);\n\n      if (token.slice(0, 1) === \"*\") {\n        token = token.slice(1);\n\n        if (type !== \"escape\" && type !== \"general\") {\n          stopTrim.push(type);\n        }\n      }\n\n      return {\n        index: index,\n        length: token.length,\n        text: \"\",\n        // Replace escaped tokens with the non-escaped token text.\n        token: type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token,\n        // Ignore type on non-moment tokens.\n        type: type === \"escape\" || type === \"general\" ? null : type\n      };\n    }); // Associate text tokens with moment tokens.\n\n    var currentToken = {\n      index: 0,\n      length: 0,\n      token: \"\",\n      text: \"\",\n      type: null\n    };\n    var tokens = [];\n\n    if (useLeftUnits) {\n      rawTokens.reverse();\n    }\n\n    each(rawTokens, function (token) {\n      if (token.type) {\n        if (currentToken.type || currentToken.text) {\n          tokens.push(currentToken);\n        }\n\n        currentToken = token;\n        return;\n      }\n\n      if (useLeftUnits) {\n        currentToken.text = token.token + currentToken.text;\n      } else {\n        currentToken.text += token.token;\n      }\n    });\n\n    if (currentToken.type || currentToken.text) {\n      tokens.push(currentToken);\n    }\n\n    if (useLeftUnits) {\n      tokens.reverse();\n    } // Find unique moment token types in the template in order of\n    // descending magnitude.\n\n\n    var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\")))); // Exit early if there are no moment token types.\n\n    if (!momentTypes.length) {\n      return pluck(tokens, \"text\").join(\"\");\n    } // Calculate values for each moment type in the template.\n    // For processing the settings, values are associated with moment types.\n    // Values will be assigned to tokens at the last step in order to\n    // assume nothing about frequency or order of tokens in the template.\n\n\n    momentTypes = map(momentTypes, function (momentType, index) {\n      // Is this the least-magnitude moment token found?\n      var isSmallest = index + 1 === momentTypes.length; // Is this the greatest-magnitude moment token found?\n\n      var isLargest = !index; // Get the raw value in the current units.\n\n      var rawValue;\n\n      if (momentType === \"years\" || momentType === \"months\") {\n        rawValue = remainderMonths.as(momentType);\n      } else {\n        rawValue = remainder.as(momentType);\n      }\n\n      var wholeValue = Math.floor(rawValue);\n      var decimalValue = rawValue - wholeValue;\n      var token = find(tokens, function (token) {\n        return momentType === token.type;\n      });\n\n      if (isLargest && maxValue && rawValue > maxValue) {\n        isMaxValue = true;\n      }\n\n      if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n        isMinValue = true;\n      } // Note the length of the largest-magnitude moment token:\n      // if it is greater than one and forceLength is not set,\n      // then default forceLength to `true`.\n      //\n      // Rationale is this: If the template is \"h:mm:ss\" and the\n      // moment value is 5 minutes, the user-friendly output is\n      // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n      // even though it has length of two if the template is \"h:mm:ss\";\n      //\n      // If the minutes output should always include the leading zero\n      // even when the hour is trimmed then set `{ forceLength: true }`\n      // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n      // clearly wanted everything padded so we should output \"05:00\";\n      //\n      // If the user wants the full padded output, they can use\n      // template \"hh:mm:ss\" and set `{ trim: false }` to output\n      // \"00:05:00\".\n\n\n      if (isLargest && forceLength === null && token.length > 1) {\n        forceLength = true;\n      } // Update remainder.\n\n\n      remainder.subtract(wholeValue, momentType);\n      remainderMonths.subtract(wholeValue, momentType);\n      return {\n        rawValue: rawValue,\n        wholeValue: wholeValue,\n        // Decimal value is only retained for the least-magnitude\n        // moment type in the format template.\n        decimalValue: isSmallest ? decimalValue : 0,\n        isSmallest: isSmallest,\n        isLargest: isLargest,\n        type: momentType,\n        // Tokens can appear multiple times in a template string,\n        // but all instances must share the same length.\n        tokenLength: token.length\n      };\n    });\n    var truncMethod = trunc ? Math.floor : Math.round;\n\n    var truncate = function (value, places) {\n      var factor = Math.pow(10, places);\n      return truncMethod(value * factor) / factor;\n    };\n\n    var foundFirst = false;\n    var bubbled = false;\n\n    var formatValue = function (momentType, index) {\n      var formatOptions = {\n        useGrouping: useGrouping,\n        groupingSeparator: groupingSeparator,\n        decimalSeparator: decimalSeparator,\n        grouping: grouping,\n        useToLocaleString: useToLocaleString\n      };\n\n      if (useSignificantDigits) {\n        if (significantDigits <= 0) {\n          momentType.rawValue = 0;\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        } else {\n          formatOptions.maximumSignificantDigits = significantDigits;\n          momentType.significantDigits = significantDigits;\n        }\n      }\n\n      if (isMaxValue && !bubbled) {\n        if (momentType.isLargest) {\n          momentType.wholeValue = maxValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n\n      if (isMinValue && !bubbled) {\n        if (momentType.isSmallest) {\n          momentType.wholeValue = minValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n\n      if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n        // Apply precision to least significant token value.\n        if (precision < 0) {\n          momentType.value = truncate(momentType.wholeValue, precision);\n        } else if (precision === 0) {\n          momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n        } else {\n          // precision > 0\n          if (useSignificantDigits) {\n            if (trunc) {\n              momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n            } else {\n              momentType.value = momentType.rawValue;\n            }\n\n            if (momentType.wholeValue) {\n              significantDigits -= momentType.wholeValue.toString().length;\n            }\n          } else {\n            formatOptions.fractionDigits = precision;\n\n            if (trunc) {\n              momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n            } else {\n              momentType.value = momentType.wholeValue + momentType.decimalValue;\n            }\n          }\n        }\n      } else {\n        if (useSignificantDigits && momentType.wholeValue) {\n          // Outer Math.round required here to handle floating point errors.\n          momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n          significantDigits -= momentType.wholeValue.toString().length;\n        } else {\n          momentType.value = momentType.wholeValue;\n        }\n      }\n\n      if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n        formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n        if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n          delete formatOptions.maximumSignificantDigits;\n        }\n      }\n\n      if (!foundFirst && (momentType.value > 0 || trim === \"\"\n      /* trim: false */\n      || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        foundFirst = true;\n      }\n\n      momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n      formatOptions.useGrouping = false;\n      formatOptions.decimalSeparator = \".\";\n      momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n      if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n        momentType.formattedValueMS = formatNumber(momentType.value, {\n          minimumIntegerDigits: 3,\n          useGrouping: false\n        }, \"en\").slice(0, 2);\n      }\n\n      return momentType;\n    }; // Calculate formatted values.\n\n\n    momentTypes = map(momentTypes, formatValue);\n    momentTypes = compact(momentTypes); // Bubble rounded values.\n\n    if (momentTypes.length > 1) {\n      var findType = function (type) {\n        return find(momentTypes, function (momentType) {\n          return momentType.type === type;\n        });\n      };\n\n      var bubbleTypes = function (bubble) {\n        var bubbleMomentType = findType(bubble.type);\n\n        if (!bubbleMomentType) {\n          return;\n        }\n\n        each(bubble.targets, function (target) {\n          var targetMomentType = findType(target.type);\n\n          if (!targetMomentType) {\n            return;\n          }\n\n          if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n            bubbleMomentType.rawValue = 0;\n            bubbleMomentType.wholeValue = 0;\n            bubbleMomentType.decimalValue = 0;\n            targetMomentType.rawValue += 1;\n            targetMomentType.wholeValue += 1;\n            targetMomentType.decimalValue = 0;\n            targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n            bubbled = true;\n          }\n        });\n      };\n\n      each(bubbles, bubbleTypes);\n    } // Recalculate formatted values.\n\n\n    if (bubbled) {\n      foundFirst = false;\n      significantDigits = significantDigitsCache;\n      momentTypes = map(momentTypes, formatValue);\n      momentTypes = compact(momentTypes);\n    }\n\n    if (outputTypes && !(isMaxValue && !settings.trim)) {\n      momentTypes = map(momentTypes, function (momentType) {\n        if (find(outputTypes, function (outputType) {\n          return momentType.type === outputType;\n        })) {\n          return momentType;\n        }\n\n        return null;\n      });\n      momentTypes = compact(momentTypes);\n    } else {\n      // Trim Large.\n      if (trimLarge) {\n        momentTypes = rest(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - the smallest moment type\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n        });\n      } // Largest.\n\n\n      if (largest && momentTypes.length) {\n        momentTypes = momentTypes.slice(0, largest);\n      } // Trim Small.\n\n\n      if (trimSmall && momentTypes.length > 1) {\n        momentTypes = initial(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          // - the largest momentType\n          return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n        });\n      } // Trim Mid.\n\n\n      if (trimMid) {\n        momentTypes = map(momentTypes, function (momentType, index) {\n          if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n            return null;\n          }\n\n          return momentType;\n        });\n        momentTypes = compact(momentTypes);\n      } // Trim Final.\n\n\n      if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n        momentTypes = [];\n      }\n    }\n\n    if (returnMomentTypes) {\n      return momentTypes;\n    } // Localize and pluralize unit labels.\n\n\n    each(tokens, function (token) {\n      var key = momentTokens[token.type];\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n\n      if (!key || !momentType) {\n        return;\n      }\n\n      var values = momentType.formattedValueEn.split(\".\");\n      values[0] = parseInt(values[0], 10);\n\n      if (values[1]) {\n        values[1] = parseFloat(\"0.\" + values[1], 10);\n      } else {\n        values[1] = null;\n      }\n\n      var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n      var labels = durationGetLabels(key, localeData);\n      var autoLocalized = false;\n      var pluralizedLabels = {}; // Auto-Localized unit labels.\n\n      each(localeData._durationLabelTypes, function (labelType) {\n        var label = find(labels, function (label) {\n          return label.type === labelType.type && label.key === pluralKey;\n        });\n\n        if (label) {\n          pluralizedLabels[label.type] = label.label;\n\n          if (stringIncludes(token.text, labelType.string)) {\n            token.text = token.text.replace(labelType.string, label.label);\n            autoLocalized = true;\n          }\n        }\n      }); // Auto-pluralized unit labels.\n\n      if (usePlural && !autoLocalized) {\n        labels.sort(durationLabelCompare);\n        each(labels, function (label) {\n          if (pluralizedLabels[label.type] === label.label) {\n            if (stringIncludes(token.text, label.label)) {\n              // Stop checking this token if its label is already\n              // correctly pluralized.\n              return false;\n            } // Skip this label if it is correct, but not present in\n            // the token's text.\n\n\n            return;\n          }\n\n          if (stringIncludes(token.text, label.label)) {\n            // Replece this token's label and stop checking.\n            token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n            return false;\n          }\n        });\n      }\n    }); // Build ouptut.\n\n    tokens = map(tokens, function (token) {\n      if (!token.type) {\n        return token.text;\n      }\n\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n\n      if (!momentType) {\n        return \"\";\n      }\n\n      var out = \"\";\n\n      if (useLeftUnits) {\n        out += token.text;\n      }\n\n      if (isNegative && isMaxValue || !isNegative && isMinValue) {\n        out += \"< \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n\n      if (isNegative && isMinValue || !isNegative && isMaxValue) {\n        out += \"> \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n\n      if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        out += \"-\";\n        isNegative = false;\n      }\n\n      if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n        out += momentType.formattedValueMS;\n      } else {\n        out += momentType.formattedValue;\n      }\n\n      if (!useLeftUnits) {\n        out += token.text;\n      }\n\n      return out;\n    }); // Trim leading and trailing comma, space, colon, and dot.\n\n    return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n  } // defaultFormatTemplate\n\n\n  function defaultFormatTemplate() {\n    var dur = this.duration;\n\n    var findType = function findType(type) {\n      return dur._data[type];\n    };\n\n    var firstType = find(this.types, findType);\n    var lastType = findLast(this.types, findType); // Default template strings for each duration dimension type.\n\n    switch (firstType) {\n      case \"milliseconds\":\n        return \"S __\";\n\n      case \"seconds\": // Fallthrough.\n\n      case \"minutes\":\n        return \"*_MS_\";\n\n      case \"hours\":\n        return \"_HMS_\";\n\n      case \"days\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"d __\";\n        }\n\n      case \"weeks\":\n        if (firstType === lastType) {\n          return \"w __\";\n        }\n\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"w __, d __, h __\";\n\n      case \"months\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"M __\";\n        }\n\n      case \"years\":\n        if (firstType === lastType) {\n          return \"y __\";\n        }\n\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"y __, M __, d __\";\n\n      default:\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"y __, d __, h __, m __, s __\";\n    }\n  } // init\n\n\n  function init(context) {\n    if (!context) {\n      throw \"Moment Duration Format init cannot find moment instance.\";\n    }\n\n    context.duration.format = durationsFormat;\n    context.duration.fn.format = durationFormat;\n    context.duration.fn.format.defaults = {\n      // Many options are defaulted to `null` to distinguish between\n      // 'not set' and 'set to `false`'\n      // trim\n      // Can be a string, a delimited list of strings, an array of strings,\n      // or a boolean.\n      // \"large\" - will trim largest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"small\" - will trim smallest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"both\" - will execute \"large\" trim then \"small\" trim.\n      // \"mid\" - will trim any zero-value tokens that are not the first or\n      // last tokens. Usually used in conjunction with \"large\" or \"both\".\n      // e.g. \"large mid\" or \"both mid\".\n      // \"final\" - will trim the final token if it is zero-value. Use this\n      // option with \"large\" or \"both\" to output an empty string when\n      // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n      // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n      // \"left\" - maps to \"large\" to support plugin's version 1 API.\n      // \"right\" - maps to \"large\" to support plugin's version 1 API.\n      // `false` - template tokens are not trimmed.\n      // `true` - treated as \"large\".\n      // `null` - treated as \"large\".\n      trim: null,\n      // stopTrim\n      // A moment token string, a delimited set of moment token strings,\n      // or an array of moment token strings. Trimming will stop when a token\n      // listed in this option is reached. A \"*\" character in the format\n      // template string will also mark a moment token as stopTrim.\n      // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n      stopTrim: null,\n      // largest\n      // Set to a positive integer to output only the \"n\" largest-magnitude\n      // moment tokens that have a value. All lesser-magnitude moment tokens\n      // will be ignored. This option takes effect even if `trim` is set\n      // to `false`.\n      largest: null,\n      // maxValue\n      // Use `maxValue` to render generalized output for large duration values,\n      // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n      /// applied to the greatest-magnitude moment token in the format template.\n      maxValue: null,\n      // minValue\n      // Use `minValue` to render generalized output for small duration values,\n      // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n      // applied to the least-magnitude moment token in the format template.\n      minValue: null,\n      // precision\n      // If a positive integer, number of decimal fraction digits to render.\n      // If a negative integer, number of integer place digits to truncate to 0.\n      // If `useSignificantDigits` is set to `true` and `precision` is a positive\n      // integer, sets the maximum number of significant digits used in the\n      // formatted output.\n      precision: 0,\n      // trunc\n      // Default behavior rounds final token value. Set to `true` to\n      // truncate final token value, which was the default behavior in\n      // version 1 of this plugin.\n      trunc: false,\n      // forceLength\n      // Force first moment token with a value to render at full length\n      // even when template is trimmed and first moment token has length of 1.\n      forceLength: null,\n      // userLocale\n      // Formatted numerical output is rendered using `toLocaleString`\n      // and the locale of the user's environment. Set this option to render\n      // numerical output using a different locale. Unit names are rendered\n      // and detected using the locale set in moment.js, which can be different\n      // from the locale of user's environment.\n      userLocale: null,\n      // usePlural\n      // Will automatically singularize or pluralize unit names when they\n      // appear in the text associated with each moment token. Standard and\n      // short unit labels are singularized and pluralized, based on locale.\n      // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n      // of \"1 seconds\" or \"1 secs\". The default pluralization function\n      // renders a plural label for a value with decimal precision.\n      // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n      // Label types and pluralization function are configurable in the\n      // localeData extensions.\n      usePlural: true,\n      // useLeftUnits\n      // The text to the right of each moment token in a format string\n      // is treated as that token's units for the purposes of trimming,\n      // singularizing, and auto-localizing.\n      // e.g. \"h [hours], m [minutes], s [seconds]\".\n      // To properly singularize or localize a format string such as\n      // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n      // to the left of each moment token, set useLeftUnits to `true`.\n      // This plugin is not tested in the context of rtl text.\n      useLeftUnits: false,\n      // useGrouping\n      // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useGrouping: true,\n      // useSignificantDigits\n      // Treat the `precision` option as the maximum significant digits\n      // to be rendered. Precision must be a positive integer. Significant\n      // digits extend across unit types,\n      // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n      // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useSignificantDigits: false,\n      // template\n      // The template string used to format the duration. May be a function\n      // or a string. Template functions are executed with the `this` binding\n      // of the settings object so that template strings may be dynamically\n      // generated based on the duration object (accessible via `this.duration`)\n      // or any of the other settings. Leading and trailing space, comma,\n      // period, and colon characters are trimmed from the resulting string.\n      template: defaultFormatTemplate,\n      // useToLocaleString\n      // Set this option to `false` to ignore the `toLocaleString` feature\n      // test and force the use of the `formatNumber` fallback function\n      // included in this plugin.\n      useToLocaleString: true,\n      // formatNumber fallback options.\n      // When `toLocaleString` is detected and passes the feature test, the\n      // following options will have no effect: `toLocaleString` will be used\n      // for formatting and the grouping separator, decimal separator, and\n      // integer digit grouping will be determined by the user locale.\n      // groupingSeparator\n      // The integer digit grouping separator used when using the fallback\n      // formatNumber function.\n      groupingSeparator: \",\",\n      // decimalSeparator\n      // The decimal separator used when using the fallback formatNumber\n      // function.\n      decimalSeparator: \".\",\n      // grouping\n      // The integer digit grouping used when using the fallback formatNumber\n      // function. Must be an array. The default value of `[3]` gives the\n      // standard 3-digit thousand/million/billion digit groupings for the\n      // \"en\" locale. Setting this option to `[3, 2]` would generate the\n      // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n      grouping: [3]\n    };\n    context.updateLocale('en', engLocale);\n  } // Run feature tests for `Number#toLocaleString`.\n\n\n  var toLocaleStringFormatter = function (number, locale, options) {\n    return number.toLocaleString(locale, options);\n  };\n\n  toLocaleStringWorks = toLocaleStringSupportsLocales() && featureTestFormatter(toLocaleStringFormatter);\n  toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestFormatterRounding(toLocaleStringFormatter); // Run feature tests for `Intl.NumberFormat#format`.\n\n  var intlNumberFormatFormatter = function (number, locale, options) {\n    if (typeof window !== 'undefined' && window && window.Intl && window.Intl.NumberFormat) {\n      return window.Intl.NumberFormat(locale, options).format(number);\n    }\n  };\n\n  intlNumberFormatWorks = featureTestFormatter(intlNumberFormatFormatter);\n  intlNumberFormatRoundingWorks = intlNumberFormatWorks && featureTestFormatterRounding(intlNumberFormatFormatter); // Initialize duration format on the global moment instance.\n\n  init(moment); // Return the init function so that duration format can be\n  // initialized on other moment instances.\n\n  return init;\n});","map":{"version":3,"names":["root","factory","define","amd","exports","module","require","e","momentDurationFormatSetup","moment","toLocaleStringWorks","toLocaleStringRoundingWorks","intlNumberFormatWorks","intlNumberFormatRoundingWorks","types","split","bubbles","type","targets","value","stringIncludes","str","search","length","indexOf","repeatZero","qty","result","stringRound","digits","digitsArray","reverse","i","carry","parseInt","toString","push","join","cachedNumberFormat","locale","options","optionsString","map","keys","sort","key","cacheKey","cache","Intl","NumberFormat","formatNumber","number","userLocale","useToLocaleString","useGrouping","grouping","slice","maximumSignificantDigits","minimumIntegerDigits","fractionDigits","groupingSeparator","decimalSeparator","localeStringOptions","maximumFractionDigits","minimumFractionDigits","roundingOptions","extend","parseFloat","format","toLocaleString","numberString","toPrecision","toFixed","integerString","fractionString","exponentString","temp","integerLength","fractionLength","digitCount","replace","exponent","Math","abs","formattedString","group","shift","durationLabelCompare","a","b","label","durationGetLabels","token","localeData","labels","each","localeDataKey","labelType","toLowerCase","labelKey","durationPluralKey","integerValue","decimalValue","engLocale","durationLabelsStandard","S","SS","s","ss","m","mm","h","hh","d","dd","w","ww","M","MM","y","yy","durationLabelsShort","durationTimeTemplates","HMS","HM","MS","durationLabelTypes","string","isArray","array","Object","prototype","call","isObject","obj","findLast","callback","index","find","max","match","item","ret","pluck","prop","compact","unique","_a","intersection","_b","rest","initial","reversed","hasOwnProperty","any","flatten","child","concat","toLocaleStringSupportsLocales","name","featureTestFormatterRounding","formatter","featureTestFormatter","passed","durationsFormat","args","arguments","settings","durations","arg","template","precision","returnMomentTypes","formattedDurations","dur","outputTypes","largest","durationFormat","defaults","asMilliseconds","asMonths","isValid","isNegative","remainder","duration","remainderMonths","momentTokens","years","months","weeks","days","hours","minutes","seconds","milliseconds","tokenDefs","escape","general","typeMap","test","tokenizer","RegExp","source","apply","stopTrim","_durationTimeTemplates","useLeftUnits","usePlural","forceLength","trunc","useSignificantDigits","significantDigits","significantDigitsCache","minValue","isMinValue","maxValue","isMaxValue","trim","trimIncludes","rLarge","rSmall","rBoth","rMid","rAll","rFinal","trimLarge","trimSmall","trimMid","trimFinal","rawTokens","text","currentToken","tokens","momentTypes","momentType","isSmallest","isLargest","rawValue","as","wholeValue","floor","subtract","tokenLength","truncMethod","round","truncate","places","factor","pow","foundFirst","bubbled","formatValue","formatOptions","formattedValue","formattedValueEn","formattedValueMS","findType","bubbleTypes","bubble","bubbleMomentType","target","targetMomentType","outputType","values","pluralKey","autoLocalized","pluralizedLabels","_durationLabelTypes","out","defaultFormatTemplate","_data","firstType","lastType","init","context","fn","updateLocale","toLocaleStringFormatter","intlNumberFormatFormatter","window"],"sources":["C:/Users/User/Desktop/show_reel/frontend/node_modules/moment-duration-format/lib/moment-duration-format.js"],"sourcesContent":["/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // `Intl.NumberFormat#format` is tested on plugin initialization.\n    // If the feature test passes, `intlNumberFormatRoundingWorks` will be set to\n    // `true` and the native function will be used to generate formatted output.\n    // If the feature test fails, either `Number#tolocaleString` (if\n    // `toLocaleStringWorks` is `true`), or the fallback format function internal\n    //  to this plugin will be used.\n    var intlNumberFormatWorks = false;\n\n    // `Intl.NumberFormat#format` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `Intl.NumberFormat#format` will be used for\n    // formatting, the plugin will \"pre-round\" number values using the fallback number\n    // format function before passing them to `Intl.NumberFormat#format` for final\n    // formatting.\n    var intlNumberFormatRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // cachedNumberFormat\n    // Returns an `Intl.NumberFormat` instance for the given locale and configuration.\n    // On first use of a particular configuration, the instance is cached for fast\n    // repeat access.\n    function cachedNumberFormat(locale, options) {\n        // Create a sorted, stringified version of `options`\n        // for use as part of the cache key\n        var optionsString = map(\n            keys(options).sort(),\n            function(key) {\n                return key + ':' + options[key];\n            }\n        ).join(',');\n\n        // Set our cache key\n        var cacheKey = locale + '+' + optionsString;\n\n        // If we don't have this configuration cached, configure and cache it\n        if (!cachedNumberFormat.cache[cacheKey]) {\n            cachedNumberFormat.cache[cacheKey] = Intl.NumberFormat(locale, options);\n        }\n\n        // Return the cached version of this configuration\n        return cachedNumberFormat.cache[cacheKey];\n    }\n    cachedNumberFormat.cache = {};\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `Intl.NumberFormat` or `toLocaleString` for formatting.\n    // `userLocale` option is passed through to the formatting function.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (intlNumberFormatWorks) {\n                if (!intlNumberFormatRoundingWorks) {\n                    var roundingOptions = extend({}, options);\n                    roundingOptions.useGrouping = false;\n                    roundingOptions.decimalSeparator = \".\";\n                    number = parseFloat(formatNumber(number, roundingOptions), 10);\n                }\n\n                return cachedNumberFormat(userLocale, localeStringOptions).format(number);\n            } else {\n                if (!toLocaleStringRoundingWorks) {\n                    var roundingOptions = extend({}, options);\n                    roundingOptions.useGrouping = false;\n                    roundingOptions.decimalSeparator = \".\";\n                    number = parseFloat(formatNumber(number, roundingOptions), 10);\n                }\n\n                return number.toLocaleString(userLocale, localeStringOptions);\n            }\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestFormatterRounding(formatter) {\n        return formatter(3.55, \"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestFormatter(formatter) {\n        var passed = true;\n\n        // Test minimumIntegerDigits.\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && formatter(1000, \"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && formatter(1000, \"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (typeof this.isValid === \"function\" && this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && (toLocaleStringWorks || intlNumberFormatWorks);\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    var toLocaleStringFormatter = function(number, locale, options) {\n        return number.toLocaleString(locale, options);\n    };\n\n    toLocaleStringWorks = toLocaleStringSupportsLocales() && featureTestFormatter(toLocaleStringFormatter);\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestFormatterRounding(toLocaleStringFormatter);\n\n    // Run feature tests for `Intl.NumberFormat#format`.\n    var intlNumberFormatFormatter = function(number, locale, options) {\n        if (typeof window !== 'undefined' && window && window.Intl && window.Intl.NumberFormat) {\n            return window.Intl.NumberFormat(locale, options).format(number);\n        }\n    };\n\n    intlNumberFormatWorks = featureTestFormatter(intlNumberFormatFormatter);\n    intlNumberFormatRoundingWorks = intlNumberFormatWorks && featureTestFormatterRounding(intlNumberFormatFormatter);\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}